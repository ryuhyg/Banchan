<?xml version="1.0" encoding="UTF-8"?>
<!-- Sql Mapper -->
<!DOCTYPE mapper
PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
"http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="member">

<!-- start 광태  -->
		<!-- <select id="selectMember" resultType="memberVO">
	 		select mem_id,pw from ban_mem
	 	</select> -->
	 	<!-- ajax id check -->
	 	<select id="checkIdOnAjax" resultType="int" parameterType="string">
					SELECT 		count(*)
					FROM  			BAN_MEM
					WHERE 		mem_id=#{value}
		</select>
	 	
	 	<!-- 비밀번호 찾기 질문 리스트 받기 -->
	 	<select id="getAllPwQnAList" resultType="pwQnaVO">
	 				SELECT 	 PW_QNA_NO, PW_QUEST
					FROM		 PW_QNA
	 	</select>
	 	
	 	<!-- 주소타입 존재하는지 확인 -->
	 	<select id="checkAddressNoByAddressAPI" parameterType="memberVO" resultType="string">
			 		SELECT 	ADDRESS_NO 
					FROM 		ADDRESS
					WHERE 	ADDRESS_API= #{addressVO.addressAPI}
	 	</select>
	 	
	 	<!-- ADDRESS 테이블에 새로운 주소지 등록 --><!-- address_API가 시스템상 유일값인데 pk처럼 중복방지 방법이 없을까요.. 현재 pk는 시퀀스인 상태고 -->
	 	<insert id="registerNewAddressInfo" parameterType="addressVO">
	 		<selectKey keyProperty="addressNo" resultType="string" order="BEFORE"> <!-- keyProperty="addressVO.addressNo" 이것도 사용가능 -->
	 				SELECT	 address_seq.nextval
	 				FROM		 dual
	 		</selectKey>
	 				INSERT INTO 	ADDRESS(ADDRESS_NO, ADDRESS_API, LATITUDE, LONGITUDE) 
					VALUES(#{addressNo},#{addressAPI},#{latitude},#{longitude})
	 	</insert>
	 	
	 	<!--  회원 정보 등록 -->
	 	<insert id="registerMember" parameterType="memberVO">
	 				INSERT INTO 	ban_mem(mem_id, pw, mem_name, birth, tel, address_de, pw_answer, enable_no, address_no, pw_qna_no)
					VALUES(#{memId},#{pw},#{memName},to_date(#{birth},'YYYY-MM-DD'),#{tel},#{addressDe},#{pwAnswer},11,#{addressVO.addressNo},#{pwQnaNo})
	 	</insert>
	 	
	 	<!-- 회원 가입시 권한 등록 -->
	 	<insert id="registerMemberBasicAuth" parameterType="memberVO">
				 	INSERT INTO	 mem_auth(mem_auth_no, mem_id, auth_no) 
					VALUES(mem_auth_seq.nextval,#{memId},'10')
	 	</insert>
	 	
	<!-- Start 위치 기반  쿼리쿼리쿼리 Query -->
		
		<!-- 회원 아이디로 addressNo 정보 받기 -->
		<select id="findMemberAddressnoById" parameterType="memberVO" resultType="string">
				SELECT		 address_no
				FROM 		 BAN_MEM
				WHERE 		 mem_id=#{memId} 
		</select>
	<!-- End 위치 기반  쿼리쿼리쿼리 Query -->
<!-- End 광태 -->

<!-- Start 우정 -->

	<resultMap type="sellerVO" id="addressRM">
		<result column="address_no" property="addressVO.addressNo"/>
		<result column="address_api" property="addressVO.addressAPI"/>
		<result column="latitude" property="addressVO.latitude"/>
		<result column="longitude" property="addressVO.longitude"/>
	</resultMap>
 	<select id="selectSellerInfo"  resultMap="addressRM" parameterType="string">
 		select b.mem_id,b.pw,b.birth,b.tel,b.address_no,a.address_api,a.latitude,a.longitude,
		b.address_de,b.pw_qna_no,b.enable_no,b.mem_name,b.pw_answer,
		s.seller_img,s.seller_info,s.seller_score
		from seller s, ban_mem b,address a
		where b.mem_id=#{value} and s.mem_id=b.mem_id and a.address_no=b.address_no
			
 	</select>
<!-- End 우정 -->

<!-- Start 정훈 -->
	<!-- <resultMap type="memberVO" id="memberRM">
		<result property="memId" column="mem_id" />
		<result property="memName" column="mem_name" />
	</resultMap> -->
	<resultMap type="sellerVO" id="sellerRM">
			<result property="memId" column="mem_id" />
			<result property="memName" column="mem_name" />
			<result property="addressVO.addressAPI" column="address_api" />
			<result property="sellerImg" column="seller_img" />
			<result property="sellerInfo" column="seller_info" />
			<result property="sellerScore" column="seller_score" />
	</resultMap>
	<select id="selectSellerTop3" resultMap="sellerRM">
	 	<![CDATA[select m.mem_id, m.mem_name, a.address_api, s.seller_img, s.seller_info, s.seller_score 
					from (select mem_id, seller_score, seller_info, seller_img, rank() over(order by seller_score desc) as rank from seller)
					s, ban_mem m, address a 
					where m.mem_id=s.mem_id and m.address_no=a.address_no and rank<=3]]>
	</select>
	<update id="getEditMembers" parameterType="sellerVO">
			//////해야됨.
	</update>
<!-- End 정훈 -->

<!-- Start 향걸 -->
	<sql id="selectMember">
 		select mem_id, pw, mem_name, birth, tel, address_de, pw_answer, enable_no, address_no, pw_qna_no from ban_mem
 	</sql> 	
 	<select id="selectMember" resultType="memberVO">
 		select mem_id,pw from ban_mem
 	</select>
 	<select id="findMemberById" resultType="memberVO">
 	 <include refid="selectMember" />
 	 where mem_id=#{value} and enable_no=11
 	</select>
 	<!-- Spring Security에서 권한 체크를 위해 사용 -->
	<select id="selectAuthorityByMemId"  resultType="authority">
		SELECT ma.mem_id, a.auth_name
		FROM mem_auth ma, auth a
		WHERE ma.auth_no=a.auth_no and ma.mem_id=#{value}
	</select>
 	<select id="idcheck" resultType="int">
		select count(*) from  ban_mem where mem_id=#{value}
	</select>
<!-- End 향걸 -->

<!-- Start 지원 -->
<!-- End 지원 -->

<!-- Start 영민 -->
<!-- End 영민 -->

<!-- Start 윤주 -->
<!-- End 윤주 -->

</mapper>










